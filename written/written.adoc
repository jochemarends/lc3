= Virtual Machines
:source-highlighter: pygments

[.text-center]
Jochem Arends

== Introduction

Virtual Machine (VM) are programs that emulates computer hardware. 
Virtual machines make it possible to run programs that aren't written for your device.
In this document I'm going to explain how I wrote a virtual machine using {cpp}.

== Little Computer 3

Little Computer 3 (LC-3) is an educational computer architecuture developed at the University of Texas at Austin.
The LC-3 has a simple yet versatile instruction set. 
Many programs for this architecture can be found online, which is great for testing the VM.
Besides programs, on the internet, tools for this architecture can be found, including an assembler and a C compiler.

== Registers

Registers are a type of computer memory that typically is build into the CPU.
This type of memory is usually faster to access for a CPU than RAM.
The LC-3 has eight 16-bit general purpose registers, these are called `R0-R7`.
These registers can be used as operands for instructions.
Besides these general purpose registers, there's also a 16-bit program counter which is ofter referred to as `PC` and three conditional codes (which I will cover later).

<<<

== Instruction Encoding

The four most significant bits of an intruction form the opcode.
The LC-3 architecture knows 15 distinct operations, which are listed below in the form of an `enum class`, but can also be found in the ISA at page number 525.

.opcodes.h
[source, cpp]
----
include::../inc/lc3/opcodes.h[tag=adoc]
----

<<<

== Instruction Decoding

Instructions consist of named bit sequences that occupy fixed sequence of bits. 
When looking at the instruction encodings (ISA page number 525) I found that many of them follow similar patterns.
For example, instruction that use a desination register, it always encode that register index at bits 11 till 9.
When looking at any other types, the same pattern can be found.
All the types are listed below together with the bits they occupy in encodings.

[cols="1,1",stripes=even]
|===
|Term |Bits

|Destination Register (`DR`)
|11..9

|Source Register (`SR`)
|11..9

|Source Register 1 (`SR1`)
|8..6

|Source Register 2 (`SR2`)
|2..0

|Base Register (`BaseR`)
|8..6

|5-bit Immediate Value (`imm5`)
|4..0

|6-bit Offset Value (`offset6`)
|5..0

|9-bit PC Offset Value (`PCoffset9`)
|8..0

|11-bit PC Offset Value (`PCoffset11`)
|10..0

|8-bit Trap Vector Value (`trapvect8`)
|7..0
|===

A nice thing of this pattern is that every type can be represented using a width and an index (where `0` refers the the LSB).
Below can be seen how these types can be represented in {cpp}.
The `lc3::word` and `lc3::sword` aliases defined in this header but will only be used later by other parts of the program.

.types.h
[source, cpp]
----
include::../inc/lc3/types.h[tag=adoc]
    /* etc.. */
}

#endif
----

Now that we've defined which bits each type occupies, we can make functions to extract the bits of these types.
`lc3::extract` extracts a single type from 16-bit data.
`lc3::decode` extracts a variable amount of type from 16-bit data.
`lc3::bit_at` extracts a single bit from an integer.

.encoding.h
[source, cpp]
----
include::../inc/lc3/encoding.h[tag=!ignore]
----

<<<

== Memory

The LC-3 architecture uses 16-bit wide addresses, each of these addresses refers to a 16-bit location in memory. 
As for now, a simple `std::array` can be used for memory.
I made it a type alias for allowing us to easily change its defenition in the future.
This can come in handy when we want to implement memory mapped IO.

.memory.h
[source, cpp]
----
include::../inc/lc3/memory.h[tag=!ignore]
----

<<<

== The CPU

Below I've pasted the declaration of a structure that represents a LC-3 CPU. It's quite a lot compared to the other code listings, but I will explain everything in detail.

.cpu.h
[source, cpp]
----
include::../inc/lc3/cpu.h[tag=!ignore]
----

=== The Public Interface

The public interface of the `lc3::cpu` class consists of three member functions: `lc3::cpu::load`, `lc3::cpu::execute`, and `lc3::cpu::run`.
The `lc3::cpu::load` function is for loading programs into memory.
It accepts any sequence of 16-bit data that conforms to the `std::ranges::input_range` concept.
By default the program gets loaded at address `0x0000` but an optional parameter can be specified in to load it at a different offset.
The `lc3::cpu::execute` function accepts a single machine code instruction and executes it.
The `lc3:;cpu::run` function keeps executing machine code instructions starting at the current program counter and keeps doing this till the CPU gets halted (which will later be explained how to).

=== The Implementation Details



On second thought it does not make much sense to keep the memory inside the CPU since they're different units.
It would make more sense if they both were part of a class that represents the machine as a whole (alternatively rename `lc3::cpu` to `lc3::machine`).
Once I've noticed this, I was already working on this document and did not bother to change it anymore.
However, it is something I would take in consideration if writing a virtual machine ever again.

=== Operations

In this section I'll explain how I've implemented all 15 operations.
I will do by

=== Addition

----
if (bit[5] == 0)
    DR=SR1+SR2;
else
    DR=SR1+SEXT(imm5);
setcc();
----

The first operation that I've implemented was addition.
Again, for a more detailed description, consult the ISA.

.Performing Addition
[source, cpp]
----
namespace lc3 {
include::../src/cpu.cpp[tag=add]
}
----

[source, cpp]
----
namespace lc3 {
include::../src/cpu.cpp[tag=sti]
}
----
